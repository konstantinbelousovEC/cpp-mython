# Mython interpreter
## Реализация интерпретатора языка программирования Mython, упрощённого подмножества Python, на C++.

### Разделы:
- Описание языка Mython:
    - Числа
    - Строки
    - Логические константы и None
    - Комментарии
    - Идентификаторы
    - Классы
    - Типизация
    - Операции
    - Функция str
    - Команда print
    - Условный оператор
    - Наследование
    - Методы
    - Семантика присваивания
    - Прочие ограничения
- Структура интерпретатора
    - Лексический анализатор
    - Runtime-модуль
    - Синтаксический анализатор
    - Классы узлов абстрактного синтаксического дерева (AST).
- Тесты
- Планы по расширению функционала
- Сборка и использование

### Описание языка Mython

В Mython есть классы и наследование, а все методы — виртуальные.

##### Числа

В языке Mython используются только целые числа. С ними можно выполнять обычные арифметические операции: сложение, вычитание, умножение, целочисленное деление.

##### Строки

Строковая константа в Mython — это последовательность произвольных символов, размещающаяся на одной строке и ограниченная двойными кавычками " или одинарными '. Поддерживается экранирование спецсимволов **'\n'**, **'\t'**, **'\\'** и **'\\"'**.

Примеры строк в Mython:
"hello"
'world'
'long string with a double quote " inside'
"another long string with a single quote ' inside"
"string with a double quote \\" inside"
'string with a single quote \\' inside'
'', "" — пустые строки.

Строки в Mython — неизменяемые.

##### Логические константы и None

Кроме строковых и целочисленных значений язык Mython поддерживает логические значения **True** и **False**. Есть также специальное значение **None**, аналог *nullptr* в С++. В отличие от C++, логические константы пишутся с большой буквы.

##### Комментарии

Mython поддерживает однострочные комментарии, начинающиеся с символа **#**. Весь следующий текст до конца текущей строки игнорируется. **#** внутри строк считается обычным символом.

##### Идентификаторы

Идентификаторы в Mython используются для обозначения имён переменных, классов и методов. Об этом далее. Идентификаторы формируются так же, как в большинстве других языков программирования: начинаются со строчной или заглавной латинской буквы либо с символа подчёркивания. Потом следует произвольная последовательность, состоящая из цифр, букв и символа подчёркивания.
Примеры правильных идентификаторов:
- x,
- _42,
- do_something,
- int2str.

Примеры неправильных идентификаторов:
- 4four — начинается с цифры;
- one;two — содержит символ, который не относится к цифрам, буквам или знакам подчёркивания.
 
##### Классы

В Mython можно определить свой тип, создав класс. Как и в С++, класс имеет поля и методы, но, в отличие от С++, поля не надо объявлять заранее.
Объявление класса начинается с ключевого слова **class**, за которым следует идентификатор имени и объявление методов класса. Пример класса «Прямоугольник»:

    class Rect:
        def __init__(w, h):
        self.w = w
        self.h = h

    def area():
        return self.w * self.h

Важные отличия классов в Mython от классов в C++:
- Специальный метод \__init__ играет роль конструктора — он автоматически вызывается при создании нового объекта класса. Метод \__init__ может отсутствовать.
- Неявный параметр всех методов — специальный параметр **self**, аналог указателя *this* в C++. Параметр **self** ссылается на текущий объект класса.
- Поля не объявляются заранее, а добавляются в объект класса при первом присваивании. Поэтому обращения к полям класса всегда надо начинать с **self.**, чтобы отличать их от локальных переменных.
- Все поля объекта — публичные.

##### Типизация

В отличие от C++, Mython — это язык с динамической типизацией. В нём тип каждой переменной определяется во время исполнения программы и может меняться в ходе её работы. Поэтому вместо «присваивания переменной значения» лучше говорить о «связывании значения с некоторым именем». Благодаря динамической типизации при первом использовании переменной не надо указывать её тип. Пример:

    x = 4 # переменная x связывается с целочисленным значением 4
    # следующей командой переменная x связывается со значением 'hello'
    x = 'hello'
    y = True
    x = y

##### Операции

В Mython определены:
- Арифметические операции для целых чисел, деление выполняется нацело. Деление на ноль вызывает ошибку времени выполнения.
- Операция конкатенации строк, например: s = 'hello, ' + 'world'.
- Операции сравнения строк и целых чисел **==**, **!=**, **<=**, **>=**, **<**, **>**; сравнение строк выполняется лексикографически.
- Логические операции **and**, **or**, **not**.
- Унарный минус.

Приоритет операций (в порядке убывания приоритета):
- Унарный минус.
- Умножение и деление.
- Сложение и вычитание.
- Операции сравнения.
- Логические операции.

Порядок вычисления выражений может быть изменён скобками:

    print 2 + 3 * 4   # выведет 14
    print (2 + 3) * 4 # выведет 20

В Mython операция сложения кроме чисел и строк применима к объектам классов со специальным методом \__add__.

Операции сравнения применяются не только к числам и строкам, но и к объектам классов, имеющих методы \__eq__ (проверка «равно») и \__lt__ (проверка «меньше»). Используя эти методы, можно реализовать все операции сравнения.

##### Функция str

Функция str преобразует переданный ей аргумент в строку. Если аргумент — объект класса, она вызывает у него специальный метод \__str__ и возвращает результат. Если метода \__str__ в классе нет, функция возвращает строковое представление адреса объекта в памяти. Примеры:
- str('Hello') вернёт строку Hello;
- str(100500) вернёт строку 100500;
- str(False) вернёт строку False;
- str(Rect(3, 4)) вернёт адрес объекта в памяти, например 0x2056fd0.

Пример класса с методом \__str__:

    class Rect(Shape):
    def __init__(w, h):
        self.w = w
        self.h = h
    
    def __str__():
    return "Rect(" + str(self.w) + 'x' + str(self.h) + ')'
    
Выражение **str(Rect(3, 4))** вернёт строку **Rect(3x4)**.

##### Команда print

Специальная команда **print** принимает набор аргументов, разделённых запятой, печатает их в стандартный вывод и дополнительно выводит перевод строки. Пример:

    x = 4
    w = 'world'
    print x, x + 6, 'Hello, ' + w 
    
Он выведет:

    4 10 Hello, world 

Команда **print** вставляет пробел между выводимыми значениями. Если ей не передать аргументы, она просто выведет перевод строки. Чтобы преобразовать каждый свой аргумент в строку, команда **print** вызывает для него функцию **str**. Таким образом, команда **print Rect(20, 15)** выведет в *stdout* строку **Rect(20x15)**.

##### Условный оператор

В Mython есть условный оператор. Его синтаксис:

    if <условие>:
        <действие 1>
        <действие 2>
        ...
        <действие N>
    else:
        <действие 1>
        <действие 2>
        ...
        <действие M> 

**<условие>** — это произвольное выражение, за которым следует двоеточие. Если условие истинно, выполняются действия под веткой **if**, если ложно — действия под веткой **else**. Наличие ветки **else** необязательно.

**<условие>** может содержать сравнения, а также логические операции **and**, **or** и **not**. Условие будет истинным или ложным в зависимости от того, какой тип имеет вычисленное выражение.

Если результат вычисления условия — значение логического типа, для проверки истинности условия используется именно оно. Примеры:
- if x > 0:
- if s != 'Jack' and s != 'Ann':

Если результат вычисления условия — число, условие истинно тогда и только тогда, когда это число не равно нулю, как в C/C++.

Если результат вычисления условия — строка, условие истинно тогда и только тогда, когда эта строка имеет ненулевую длину.

Если результат вычисления условия — объект класса, условие истинно.

Если результат вычисления условия — **None**, условие ложно.

Действия в ветках **if** и **else** набраны с отступом в два пробела. В отличие от C++, в котором блоки кода обрамляются фигурными скобками, в языке Mython команды объединяются в блоки отступами. Один отступ равен двум пробелам. Отступ в нечётное количество пробелов считается некорректным.

##### Наследование

В языке Mython у класса может быть один родительский класс. Если он есть, он указывается в скобках после имени класса и до символа двоеточия. В примере ниже класс Rect наследуется от класса Shape:

    class Shape:
      def __str__():
        return "Shape"
        
      def area():
        return 'Not implemented'
    
    class Rect(Shape):
      def __init__(w, h):
        self.w = w
        self.h = h
    
      def __str__():
        return "Rect(" + str(self.w) + 'x' + str(self.h) + ')'
    
      def area():
        return self.w * self.h 

Наследование в Mython работает так же, как в C++, — все методы родительского класса становятся доступны классу-потомку. При этом все методы публичные и виртуальные. Например, код ниже выведет ***Hello, John***:

    class Greeting:
      def greet():
        return "Hello, " + self.name()
    
      def name():
        return 'Noname'
    
    class HelloJohn(Greeting):
      def name():
        return 'John'
    
    greet_john = HelloJohn()
    print greet_john.greet()

##### Методы

Методы в Mython имеют синтаксис:

    def <имя метода>(<список параметров>):
      <действие 1>
      <действие 2>
      ...
      <действие N> 
      
Ключевое слово **def** располагается с отступом в два пробела относительно класса. Инструкции, составляющие тело метода, имеют отступ в два пробела относительно ключевого слова **def**. Как и в случае полей класса, обращения к полям и методам текущего класса надо начинать с **self.**:

    class Factorial:
      def calc(n):
        if n == 0:
          return 1
        return n * self.calc(n - 1)
    
    fact = Factorial()
    print fact.calc(4) # Prints 24 
 
Этот пример также показывает поддержку рекурсии, которая компенсирует отсутствие циклов в языке. Команда **return** завершает выполнение метода и возвращает из него результат вычисления своего аргумента. Если исполнение метода не достигает команды **return**, метод возвращает **None**.

##### Семантика присваивания

Как сказано выше, Mython — это язык с динамической типизацией, поэтому операция присваивания имеет семантику не копирования значения в область памяти, а связывания имени переменной со значением. Как следствие, переменные только ссылаются на значения, а не содержат их копии. Говоря терминологией С++, переменные в Mython — указатели. Аналог *nullptr* — значение **None**. Код ниже выведет 2, так как переменные x и y ссылаются на один и тот же объект:

    class Counter:
      def __init__():
        self.value = 0
    
      def add():
        self.value = self.value + 1
    
    x = Counter()
    y = x
    x.add()
    y.add()
    print x.value 

##### Прочие ограничения

Результат вызова метода или конструктора в Mython — терминальная операция. Её результат можно присвоить переменной или использовать в виде параметра функции или команды, но обратиться к полям и методам возвращённого объекта напрямую нельзя:

    # Так нельзя
    print Rect(10, 5).w
    # А вот так можно
    r = Rect(10, 5)
    print r.w 

### Структура интерпретатора

На самом высоком уровне интерпретатор можно представить как средство, на вход которому поступает текст программы и входные данные. Интерпретатор выполняет операции, указанные в программе, над входными данными и выдаёт выходные данные.

Язык Mython не имеет операций для ввода данных, поэтому его интерпретатор устроен несколько проще: на вход поступает текст программы, а интерпретатор должен вывести в выходной поток результат всех команд **print**. 

Заглянув внутрь интерпретатора, увидим, что он состоит из четырёх основных логических блоков:
- Лексический анализатор, или лексер.
- Синтаксический анализатор, или парсер.
- Семантический анализатор.
- Таблица символов.
 
Первая фаза называется лексический анализ или сканирование. Лексический анализатор — его также называют сканером или лексером — считывает последовательность символов, которые составляют исходную программу, и формирует из них значащие последовательности символов — лексемы. Для каждой лексемы анализатор строит выходной токен вида:

    <имя токена, значение атрибута>

Этот токен передаётся следующей фазе, синтаксическому анализу. Имя токена — абстрактный символ, использующийся во время синтаксического анализа, а опциональное значение атрибута содержит дополнительную информацию, связанную с токеном.

Вторая фаза называется синтаксический анализ или разбор, а по-английски parsing. Анализатор — его ещё называют парсер — использует токены, полученные при лексическом анализе для создания промежуточного представления. Оно описывает грамматическую структуру потока токенов. Обычно такое представление — это абстрактное синтаксическое дерево, древовидная структура данных, в которой каждый внутренний узел задаёт операцию, а дочерние узлы — аргументы этой операции.

Построенное синтаксическое дерево передаётся в семантический анализатор.

Семантический анализатор выполняет интерпретацию программы. Он последовательно обходит синтаксическое дерево, выполняя связанные с узлами дерева действия, и обновляет таблицу символов.

#### Лексический анализатор

Класс **Lexer** выполняет лексический разбор программы. Этот класс принимает ссылку на поток ввода, из которого считывает текст программы, и выдаёт последовательность лексем программы на языке Mython.

- Метод [*CurrentToken*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/lexer.h#L94) возвращает ссылку на последнюю лексему, считанную лексером, или **token_type::Eof**, если поток токенов закончился. Этот метод можно вызывать у объекта сразу после его создания.
- Метод [*NextToken*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/lexer.h#L95) считывает и возвращает очередную лексему из входного потока. Если входной поток пуст, метод должен вернуть лексему **token_type::Eof**. После выполнения метода *NextToken* метод *CurrentToken* должен возвращать ссылку на только что считанную лексему.

В процессе разбора часто известно, какая лексема должна быть следующей. Например, после имени класса идёт двоеточие. Если встречается другая лексема, значит, на вход поступила некорректная программа. В таком случае нужно сообщить об ошибке. Для этого служат методы *Expect**:
- Шаблонный метод [*Expect<T>()*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/lexer.h#L98) проверяет, что *CurrentToken()* имеет тип **T**. Если это не так, он бросает исключение **LexerError**.
- Шаблонный метод [*Expect<T, U>(const U& value)*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/lexer.h#L101) не только проверяет, что CurrentToken() имеет тип **T**, но и что значение текущей лексемы равно **value**.
- Наконец, методы [*ExpectNext*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/lexer.h#L104) сначала вызывают *NextToken*, а затем — соответствующий метод *Expect*.

#### Runtime-модуль

Runtime-модуль интерпретатора отвечает за управлением состояния программы во время её работы. Этот модуль реализует встроенные типы данных языка Mython и таблицу символов.

Mython — язык с динамической типизацией. Переменная в Mython — это имя, которое в ходе работы программы может быть связано то с одним, то с другим значением одного из следующих типов: строки, числа, логический тип, специальное значение **None**, аналог *nullptr* в C++, экземпляр пользовательского класса.
Присваивание переменной нового значения привязывает его к новому объекту:

    class Point:
    def __init__(x, y):
        self.x = x
        self.y = y
    
    p1 = Point(1, 10)
    p2 = p1
    p1.x = 2
    print p2.x  # Выведет 2 

В этой программе операция присваивания p2 = p1 привязывает имя p2 к значению, на которое ссылается переменная p1.  В результате в таблице символов имена p1 и p2 будут ссылаться на один и тот же экземпляр класса Point.

Таким образом, переменные в Mython ведут себя очень похоже на указатели в C++.

Для единообразной работы с объектами Mython вводится абстрактный класс [*Object*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L18). Его единственный чисто виртуальный метод *Print* будет выводить строковое представление объекта в заданный поток вывода. Наследники *Object*, отвечающие за хранение конкретных типов объектов, переопределят этот метод в соответствии с требованиями языка.

классы-наследники *Object*:

- Шаблонный класс [*ValueObject<T>*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L52) — основа для представления объектов-значений: строк, чисел и логических значений. Параметр **T** задаёт тип для хранения значений — **int**, **std::string** или **bool**. На основе шаблона *ValueObject* определены классы *String*, *Bool* и *Number*.
- [*Class*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L95) хранит информацию о пользовательском классе: набор собственных методов класса и ссылку на класс-родитель. Этот класс будет рассмотрен ниже.
- [*ClassInstance*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L108) — экземпляр класса, хранит значения полей.

Метод *Object::Print* использует интерфейс [*Context*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L11). Этот интерфейс обеспечивает связь интерпретатора Mython с внешним миром. Без него результаты работы программы оставались бы невидимыми для пользователя. Метод *Context::GetOutputStream()* возвращает ссылку на поток вывода, в который интерпретатор выводит данные, встретив команду *print*. В следующем примере функция *str* вызовет метод \__str__ экземпляра класса Point:

    class Point:
    def __str__():
        print "__str__"
        return "Point"

    s = str(Point())

Чтобы получить представление экземпляра Point в виде строки, интерпретатор должен выполнить метод \__str__, содержащий команду **print**. С этой целью в метод *Object::Print* передаётся контекст для вывода. Благодаря такому архитектурному решению интерпретатор сможет выводить данные в любой поток вывода, а не только в *std::cout*. Это облегчает юнит-тестирование интерпретатора: тесты смогут использовать реализацию интерфейса *Context*, возвращающую ссылку на *ostringstream*:

Если в будущем будет необходиость добавить в Mython команду **input** для считывания пользовательского ввода, потребуется всего лишь объявить соответствующий метод в интерфейс *Context*:

    class Context {
    public:
        virtual std::ostream& GetOutputStream() = 0;
        virtual std::istream& GetInputStream() = 0;
    protected:
        ~Context() = default;
    };

Таким образом, все объекты в Mython — экземпляры классов-наследников *Object*, а переменные — именованные ссылки, связанные с этими объектами. Интерпретатор динамически создаёт и удаляет объекты, когда вычисляются выражения, создаются новые переменные или возвращаются значения из функций. Один из самых простых способов работы с такими объектами — создавать их в динамической памяти, а для управления их временем жизни использовать умные указатели.
Для этой цели лучшим выбором будет *std::shared_ptr*. С его использованием несколько переменных смогут ссылаться на один и тот же объект, а *std::unique_ptr* этого не позволяет.


Чтобы сделать работу с объектами Mython удобнее необходим вспомогательный класс-обёртка *ObjectHolder*. Он содержит методы, которые облегчают конструирование объектов и доступ к их значению.

Статические методы класса *ObjectHolder* создают новые объекты:
- Метод [*Own<T>*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L29) копирует или перемещает значение конкретного класса-наследника *Object* в динамическую память и возвращает владеющий этим объектом *ObjectHolder*. Копии возвращённого *ObjectHolder* будут также совместно владеть объектом. Это основной способ создания *ObjectHolder*.
- Метод [*Share*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L32) возвращает невладеющий *ObjectHolder*, который ссылается на существующий объект, но не контролирует время жизни. Такой способ создания *ObjectHolder* применяется для передачи **self** при вызове методов. Удобен он и для применения в юнит-тестах.
- Метод [*None*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L33) возвращает «пустой» *ObjectHolder*, эквивалентный значению **None**.


Тогда таблицу символов легко представить в виде *unordered_map*. Её ключи — это строки, задающие имена объектов, а значения — *ObjectHolder*:

    using Closure = std::unordered_map<std::string, ObjectHolder>;

Произвольный исполняемый фрагмент кода на языке Mython, будь то отдельная инструкция, метод класса или программа, можно представить в виде функции, которая принимает таблицу символов и использует *Context* доступа к потокам ввода/вывода. Результат работы этого фрагмента — один из типов языка Mython либо пустое значение **None**.
Выполнение Mython-программы — задача семантического анализатора. Чтобы связать runtime-модуль с семантическим анализатором необходим интерфейс *Executable*:

    class Executable {
    public:
        virtual ~Executable() = default;
        virtual ObjectHolder Execute(Closure& closure, Context& context) = 0;
    };

***

Класс [*ClassInstance*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L108) представляет экземпляр пользовательского класса:
- Метод [*Print*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L112) выводит в выходной поток строковое представление объекта, если его класс имеет метод \__str__. В противном случае выводит адрес объекта в памяти.
- Метод [*HasMethod*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L114) определяет, есть ли у объекта метод с указанным именем и количеством аргументов.
- Метод [*Call*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L113) вызывает метод класса, передавая ему аргументы. Возвращает результат, возвращённый из метода. Если ни класс, ни его родители не содержат метод с таким именем, выбрасывается исключение *std::runtime_error*.
- Метод [*Fields*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L115) возвращает ссылку на объект *Closure*, содержащий поля объекта.

Класс [*Class*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L95) представляет пользовательский класс:
- Метод [*GetMethod*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L99) возвращает адрес метода класса. Если в классе нет метода с указанным именем, метод ищется у его родителей. Если метод не был найден ни у самого класса, ни у его родителей, возвращается нулевой указатель.
- Метод [*GetName*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L100) возвращает имя класса
- Метод [*Print*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L101) выводит в выходной поток строку вида *Class* ИмяКласса

#### Синтаксический анализатор

Синтаксический анализатор (парсер), используя токены, поступающие от лексического анализатора, формирует абстрактное синтаксическое дерево. Узлы этого дерева — классы, которые реализуют интерфейс [*Executable*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/runtime.h#L73), соответствующие синтаксическим конструкциям языка Mython.

![](./images/parser.cpp)

Парсер возвращает объект, реализующий интерфейс *Executable*. Метод *Execute* этого интерфейса выполняет Mython-программу.


#### Классы узлов абстрактного синтаксического дерева (AST).

Парсер использует эти классы в процессе построения AST.

- [*ValueStatement*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L11) - выражение, возвращающее значение типа **T**, используется как основа для создания констант.
- [*VariableValue*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L28) - Вычисляет значение переменной либо цепочки вызовов полей объектов **id1.id2.id3**.
- [*Assignment*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L38) - присваивает переменной значение выражения;
- [*FieldAssignment*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L49) - присваивает полю объекта значение выражения;
- [*None*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L60) - значение **None**;
- [*Print*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L68) - команда **print**;
- [*MethodCall*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L79) - вызывает метод объекта со списком параметров;
- [*NewInstance*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L91) - Создаёт новый экземпляр класса *class_*, передавая его конструктору набор параметров *args*. Если в классе отсутствует метод \__init__ с заданным количеством аргументов, то экземпляр класса создаётся без вызова конструктора (поля объекта не будут проинициализированы)
- [*UnaryOperation*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L102) - базовый класс для унарных операций;
- [*Stringify*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L110) - операция **str**, возвращающая строковое значение своего аргумента;
- [*BinaryOperation*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L117) - родительский класс Бинарная операция с аргументами *lhs* и *rhs*;
- [*Add*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L126) - возвращает результат сложения аргументов *lhs* и *rhs*;
- [*Sub*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L133) - возвращает результат вычитания аргументов *lhs* и *rhs*;
- [*Mult*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L140) - возвращает результат умножения аргументов *lhs* и *rhs*;
- [*Div*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L147) - возвращает результат деления аргументов *lhs* и *rhs*;
- [*Or*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L154) - Возвращает результат вычисления логической операции **or** над *lhs* и *rhs*:
- [*And*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L161) - Возвращает результат вычисления логической операции **and** над *lhs* и *rhs*:
- [*Not*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L168) - Возвращает результат вычисления логической операции **not** над *lhs* и *rhs*:
- [*Compound*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L175) - cоставная инструкция (например: тело метода, содержимое ветки **if**, либо **else**):
- [*MethodBody*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L188) - тело метода. Как правило, содержит составную инструкцию;
- [*Return*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L197) - выполняет инструкцию **return** с выражением *statement*;
- [*ClassDefinition*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L207) - объявляет класс;
- [*IfElse*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L216) - инструкция **if <condition> <if_body> else <else_body>**;
- [*Comparison*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/statement.h#L228) - операция сравнения.

### Тесты.

- [*lexer_test_open.cpp8](https://github.com/konstantinbelousovEC/cpp-mython/blob/main/mython/lexer_test_open.cpp) - набор тестов к лексичсекому анализатору
- [*parse_test.cpp*](https://github.com/konstantinbelousovEC/cpp-mython/blob/main/mython/parse_test.cpp) - набор тестов к синтаксическому анализатору
- [*runtime_test.cpp*](https://github.com/konstantinbelousovEC/cpp-mython/blob/main/mython/runtime_test.cpp) - набор тестов к runtime-модулю
- [*statement_test.cpp*](https://github.com/konstantinbelousovEC/cpp-mython/blob/main/mython/statement_test.cpp) - набор тестов к узлам синтаксического дерева
- в [*main.cpp*](https://github.com/konstantinbelousovEC/cpp-mython/blob/main/mython/main.cpp) - также набор общих тестов

### Планы по расширению функционала.

- Циклы **for/while**
- Операции с вещественными числами
- Пользовательский ввод данных

### Сборка и использование.

Необходим современный компилятор, поддерживающий стандарт C++17 и выше.
Сборку можно производить как с помощью IDE, так и в окне терминала операционной системы.

Для запуска интерпретатора в функции main файла main.cpp необходимо вызвать функцию [*RunMythonProgram*](https://github.com/konstantinbelousovEC/cpp-mython/blob/3b4bd67629c5ad28bb5d41ed8fef6e9cd467c67e/mython/main.cpp#L27) с аргументами входного и выходного потоков. При запуске исполняемого файла *RunMythonProgram* с входного потока считает инструкции программы на языке Mython и выведет результаты вычислений (если таковые имеются) в указанный поток вывода.

